<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Video test page</title>
  </head>

  <body style="border: black 1px solid; width: 100%">
    <h1 id="status">Loading...</h1>
    <button id="startbutton" onclick="start()" hidden>Start</button>
    <button id="pausebutton" onclick="pause()" hidden>Pause</button>
    <div>
      <p>SRC</p>
      <video
        id="src_video"
        width="256"
        height="144"
        crossorigin="anonymous"
        muted
        src="https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
      ></video>
    </div>
    <div>
      <p>DST</p>
      <a id="download_link" href="#">Download</a>
      <div>
        <p>video</p>
        <!-- <video id="dst_video" width="2560" height="1440"></video> -->

        <p>canvas</p>
        <canvas id="exp_video" width="256" height="144"></canvas>
      </div>
    </div>
    <div>
      <p>cv</p>
      <canvas id="canvasOutput"></canvas>
    </div>
    <script src="./src/opencv/utils.js" type="text/javascript"></script>
    <script async src="./src/opencv/opencv.js" type="text/javascript"></script>
    <script>
      var Module = {
        // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
        onRuntimeInitialized() {
          console.log("READY!");
          const startButton = document.getElementById("startbutton");
          const pauseButton = document.getElementById("pausebutton");
          const status = document.getElementById("status");
          status.innerText = "START!!";

          startButton.hidden = false;
          pauseButton.hidden = false;
        },
      };
      const W = 320;
      const H = 240;
      function pause() {
        const srcVideo = document.getElementById("src_video");
        const dstVideo = document.getElementById("dst_video");

        srcVideo.pause();
        stopRecording();
        // dstVideo.pause();
      }
      function start() {
        const srcVideo = document.getElementById("src_video");
        const dstVideo = document.getElementById("dst_video");
        //# interpolation만 사용한다면 stream api사용할 필요는 없는 듯 함.
        // buildVSRPipleline(srcVideo, dstVideo, createTransform(1920, 1080));

        async function interpol() {
          let cap = new cv.VideoCapture(srcVideo);

          let mat = new cv.Mat(srcVideo.height, srcVideo.width, cv.CV_8UC4);
          await cap.read(mat);
          // console.log("cv_ori: ", srcVideo);
          let dst = new cv.Mat();

          let dsize = new cv.Size(1960, 1080);

          cv.resize(mat, dst, dsize, 0, 0, cv.INTER_CUBIC);
          // console.log("cv_dst: ", dst.data);
          cv.imshow("exp_video", dst);

          mat.delete();
          dst.delete();
          setTimeout(() => {
            interpol();
          }, 0);
        }
        setTimeout(() => interpol(), 0);

        srcVideo.play();
        startRecording();
        // dstVideo.play();
      }

      // https://github.com/mganeko/videotrackreader_demo/blob/main/videotrackreader.html
      let recorder = null;
      let canvasStream = null;
      function startRecording() {
        if (recorder) {
          console.warn('reacorder ALREADY started');
          return;
        }

        const fps = 30;
        const interval = 1000;
        const canvas = document.getElementById("exp_video");
        canvasStream = canvas.captureStream(fps);
        recodingChunks = [];
        recorder = new MediaRecorder(canvasStream);
        recorder.ondataavailable = function (evt) {
          recodingChunks.push(evt.data);
        };
        recorder.onstop = function (evt) {
          console.log('Stop recording');
          recorder = null;
          buildRecordedVideo();
          setupDownloadLink();
        };

        recorder.start(interval);
        console.log('Start recording');
      }


      let videoBlobUrl = null;
      function buildRecordedVideo() {
        const videoBlob = new Blob(recodingChunks, { type: "video/mp4" });
        videoBlobUrl = window.URL.createObjectURL(videoBlob);
      }
    
      function setupDownloadLink() {
        const anchor = document.getElementById('download_link');
        anchor.download = 'recorded_reader.mp4'; // ファイル名
        anchor.href = videoBlobUrl; // createObjecURL()で生成したURL
      }

      function stopRecording() {
        if (recorder) {
          recorder.stop();
          stopMediaStream(canvasStream);
          canvasStream = null;
        }
      }
    
      function stopMediaStream(stream) {
        if (stream) {
          stream.getTracks().forEach(track => {
            track.stop()
          });
        }
      }

      function buildVSRPipleline(srcVideo, dstVideo, vsrTransformer) {
        const srcTrack = getVideoTrack(srcVideo);
        const trackProcessor = new MediaStreamTrackProcessor({
          track: srcTrack,
        });
        const trackGenerator = new MediaStreamTrackGenerator({ kind: "video" });

        trackProcessor.readable
          .pipeThrough(vsrTransformer)
          .pipeTo(trackGenerator.writable);

        const outStream = new MediaStream([trackGenerator]);
        dstVideo.srcObject = outStream;
      }

      function createTransform(px, py) {
        return new TransformStream({
          async transform(videoFrame, controller) {
            const buffer = new Uint8Array(videoFrame.allocationSize());
            const layout = await videoFrame.copyTo(buffer);
            const l = buffer.length / 4;

            const init = {
              timestamp: videoFrame.timestamp,
              codedWidth: videoFrame.codedWidth,
              codedHeight: videoFrame.codedHeight,

              format: videoFrame.format,
            };

            const newFrame = new VideoFrame(buffer, init);
            videoFrame.close();
            controller.enqueue(newFrame);
          },
        });
      }

      function getVideoTrack(video) {
        const [track] = video.captureStream().getVideoTracks();
        video.onended = (evt) => track.stop();
        return track;
      }
    </script>
  </body>
</html>
